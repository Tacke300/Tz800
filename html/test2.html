<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Binance Futures Leverage Info</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #121212; color: #eee; }
  table { border-collapse: collapse; width: 100%; max-width: 900px; margin: auto; }
  th, td { border: 1px solid #444; padding: 8px 12px; text-align: center; }
  th { background-color: #222; }
  tr:nth-child(even) { background-color: #1a1a1a; }
</style>
</head>
<body>

<h1>Binance Futures Leverage Info for User</h1>
<p id="status">Loading...</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Max Leverage</th>
      <th>Current Leverage</th>
      <th>Position Amount</th>
    </tr>
  </thead>
  <tbody id="table-body">
    <tr><td colspan="4">Loading data...</td></tr>
  </tbody>
</table>

<script>
  // --- Supabase config ---
  const SUPABASE_URL = 'https://tramnanrzruzvkehpydl.supabase.co';  // Thay bằng URL dự án Supabase bạn
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRyYW1uYW5yenJ1enZrZWhweWRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU3NTM1NTMsImV4cCI6MjA2MTMyOTU1M30.L0Ytkxi80AbYjkjpDfGyQtfyfqjfHLF98OrVce9Hi-0';               // Thay bằng public anon key Supabase

  // Hàm gọi Supabase API lấy apikey_binance, secret_binance dựa user_id
  async function getBinanceApiKeys(user_id) {
    const url = `${SUPABASE_URL}/rest/v1/users?select=apikey_binance,secret_binance&id=eq.${user_id}`;
    const res = await fetch(url, {
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    });
    if (!res.ok) throw new Error('Failed to fetch user keys from Supabase');
    const data = await res.json();
    if (data.length === 0) throw new Error('User not found or no API keys');
    return data[0];
  }

  // Binance API ký request với HMAC SHA256
  function signQuery(queryString, secret) {
    return CryptoJS.HmacSHA256(queryString, secret).toString(CryptoJS.enc.Hex);
  }

  // Lấy thời gian hiện tại timestamp (ms)
  function getTimestamp() {
    return Date.now();
  }

  // Gọi Binance futures API với API key/secret, return JSON
  async function binanceFuturesApi(path, apiKey, secret, params = {}) {
    params.timestamp = getTimestamp();
    const query = new URLSearchParams(params).toString();
    const signature = signQuery(query, secret);
    const fullQuery = query + `&signature=${signature}`;

    const url = `https://fapi.binance.com${path}?${fullQuery}`;
    const res = await fetch(url, {
      headers: { 'X-MBX-APIKEY': apiKey },
    });
    if (!res.ok) {
      const err = await res.text();
      throw new Error(`Binance API error: ${res.status} ${err}`);
    }
    return res.json();
  }

  // Lấy info exchange để lấy max leverage per symbol
  async function getExchangeInfo() {
    const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
    if (!res.ok) throw new Error('Failed to get exchangeInfo');
    return res.json();
  }

  async function main() {
    const statusEl = document.getElementById('status');
    const tbody = document.getElementById('table-body');
    tbody.innerHTML = '<tr><td colspan="4">Loading...</td></tr>';

    try {
      const user_id = localStorage.getItem('user_id');
      if (!user_id) throw new Error('User ID not found in localStorage');

      statusEl.textContent = `Fetching API keys for user ${user_id}...`;

      const keys = await getBinanceApiKeys(user_id);
      statusEl.textContent = 'Got API keys. Fetching Binance data...';

      const positions = await binanceFuturesApi('/fapi/v2/positionRisk', keys.apikey_binance, keys.secret_binance);
      const exchangeInfo = await getExchangeInfo();

      const symbolInfoMap = {};
      for (const sym of exchangeInfo.symbols) {
        let maxLev = 'N/A';
        const levFilter = sym.filters.find(f => f.filterType === 'leverageFilter');
        if (levFilter) maxLev = levFilter.maxLeverage;
        symbolInfoMap[sym.symbol] = maxLev;
      }

      const positionMap = {};
      positions.forEach(pos => {
        positionMap[pos.symbol] = pos;
      });

      let rows = '';
      for (const symbol in symbolInfoMap) {
        const maxLev = symbolInfoMap[symbol];
        const pos = positionMap[symbol];
        const currentLev = pos ? pos.leverage : '-';
        const positionAmt = pos ? pos.positionAmt : '0';

        rows += `<tr>
          <td>${symbol}</td>
          <td>${maxLev}</td>
          <td>${currentLev}</td>
          <td>${positionAmt}</td>
        </tr>`;
      }

      tbody.innerHTML = rows;
      statusEl.textContent = 'Data loaded.';

    } catch (e) {
      statusEl.textContent = `Error: ${e.message}`;
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="4">Error loading data</td></tr>`;
    }
  }

  function loadCryptoAndRun() {
    if (typeof CryptoJS === 'undefined') {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js';
      script.onload = main;
      script.onerror = () => {
        document.getElementById('status').textContent = 'Failed to load CryptoJS';
      };
      document.head.appendChild(script);
    } else {
      main();
    }
  }

  loadCryptoAndRun();
</script>

</body>
</html>
