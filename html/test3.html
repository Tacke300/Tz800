<!DOCTYPE html>
<html>
<head>
  <title>Binance Full Balance</title>
  <style>
    body { font-family: Arial; padding: 20px; }
    pre { background: #f9f9f9; padding: 10px; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>

<h2>Binance All Balances (Spot, USDM, COINM)</h2>
<pre id="log">ƒêang t·∫£i...</pre>

<script>
const SUPABASE_URL = 'https://tramnanrzruzvkehpydl.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRyYW1uYW5yenJ1enZrZWhweWRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU3NTM1NTMsImV4cCI6MjA2MTMyOTU1M30.L0Ytkxi80AbYjkjpDfGyQtfyfqjfHLF98OrVce9Hi-0'; // Thay b·∫±ng c·ªßa b·∫°n
const userId = localStorage.getItem('user_id');  // Ph·∫£i c√≥ user_id trong localStorage

const logEl = document.getElementById('log');
function log(msg) {
  console.log(msg);
  logEl.textContent += '\n' + msg;
}

function hmacSHA256(key, message) {
  if (!key || !message) throw new Error('Key ho·∫∑c message kh√¥ng h·ª£p l·ªá');
  return CryptoJS.HmacSHA256(message, key).toString(CryptoJS.enc.Hex);
}

async function signedRequest(apiKey, secret, endpoint, base = 'https://api.binance.com', params = {}) {
  params.timestamp = Date.now().toString();
  const query = new URLSearchParams(params).toString();

  if (!secret) throw new Error('Secret key b·ªã r·ªóng ho·∫∑c kh√¥ng h·ª£p l·ªá');
  if (!query) throw new Error('Query string b·ªã r·ªóng ho·∫∑c kh√¥ng h·ª£p l·ªá');

  const signature = hmacSHA256(secret, query);
  const url = `${base}${endpoint}?${query}&signature=${signature}`;

  log(`üîó Request: ${url}`);

  const res = await fetch(url, { headers: { 'X-MBX-APIKEY': apiKey } });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${endpoint} failed: ${res.status} ${text}`);
  }
  return res.json();
}

async function getApiKeysFromSupabase(userId) {
  if (!userId) throw new Error('Kh√¥ng c√≥ user_id trong localStorage');

  const url = `${SUPABASE_URL}/rest/v1/users?user_id=eq.${userId}`;
  const res = await fetch(url, {
    headers: {
      apikey: SUPABASE_ANON_KEY,
      Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
      Accept: 'application/json'
    }
  });

  if (!res.ok) throw new Error('L·∫•y API key t·ª´ Supabase th·∫•t b·∫°i');

  const data = await res.json();
  if (!data.length) throw new Error('Kh√¥ng t√¨m th·∫•y user trong Supabase');

  return { apiKey: data[0].apikey_binance, apiSecret: data[0].secret_binance };
}

async function fetchBalances() {
  try {
    log(`‚ñ∂ L·∫•y API key cho user_id = ${userId}`);
    const { apiKey, apiSecret } = await getApiKeysFromSupabase(userId);
    log(`‚úî API Key: ${apiKey.slice(0, 6)}...`);
    log(`‚úî API Secret: ${apiSecret.slice(0, 6)}...`);

    // Spot Balances
    log('\n‚ñ∂ L·∫•y s·ªë d∆∞ SPOT...');
    const spotData = await signedRequest(apiKey, apiSecret, '/sapi/v1/capital/config/getall');
    const spotBalances = spotData.filter(b => parseFloat(b.free) > 0 || parseFloat(b.locked) > 0);
    log('== SPOT ==');
    spotBalances.forEach(b => {
      const total = (parseFloat(b.free) + parseFloat(b.locked)).toFixed(8);
      log(`${b.coin}: ${total}`);
    });

    // USDM Futures Balances
    log('\n‚ñ∂ L·∫•y s·ªë d∆∞ USDM...');
    const usdmData = await signedRequest(apiKey, apiSecret, '/fapi/v2/account', 'https://fapi.binance.com');
    const usdmBalances = usdmData.assets.filter(b => parseFloat(b.walletBalance) !== 0);
    log('== USDM ==');
    usdmBalances.forEach(b => {
      log(`${b.asset}: ${parseFloat(b.walletBalance).toFixed(8)}`);
    });

    // COINM Futures Balances
    log('\n‚ñ∂ L·∫•y s·ªë d∆∞ COINM...');
    const coinmData = await signedRequest(apiKey, apiSecret, '/dapi/v1/account', 'https://dapi.binance.com');
    const coinmBalances = coinmData.assets.filter(b => parseFloat(b.walletBalance) !== 0);
    log('== COINM ==');
    coinmBalances.forEach(b => {
      log(`${b.asset}: ${parseFloat(b.walletBalance).toFixed(8)}`);
    });

    log('\n‚úÖ Ho√†n t·∫•t.');
  } catch (err) {
    log('\n‚ùå L·ªói: ' + err.message);
  }
}

fetchBalances();
</script>

</body>
</html>
